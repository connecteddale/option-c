---
phase: 03-feedback-error-handling
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - OptionC/Services/NotificationManager.swift
  - OptionC/OptionCApp.swift
autonomous: true

must_haves:
  truths:
    - "Notification appears when transcription is ready and copied to clipboard"
    - "Notification appears if transcription fails (with reason)"
    - "Notifications are delivered via system notification center"
  artifacts:
    - path: "OptionC/Services/NotificationManager.swift"
      provides: "System notification delivery for success/error states"
      exports: ["NotificationManager"]
      contains: "UNUserNotificationCenter"
    - path: "OptionC/OptionCApp.swift"
      provides: "Notification permission request on launch"
      contains: "requestAuthorization"
  key_links:
    - from: "OptionC/Services/NotificationManager.swift"
      to: "UNUserNotificationCenter"
      via: "notification delivery"
      pattern: "UNNotificationRequest"
    - from: "OptionC/OptionCApp.swift"
      to: "NotificationManager"
      via: "permission request on init"
      pattern: "requestPermission"
---

<objective>
Create the notification system for delivering success and error feedback to users via macOS system notifications.

Purpose: Users need immediate, clear feedback when transcription completes or fails. System notifications provide non-intrusive alerts that work even when the user has switched to another app.

Output: NotificationManager class for sending success/error/timeout notifications, with notification permission requested at app launch.
</objective>

<execution_context>
@/Users/connecteddale/.claude/get-shit-done/workflows/execute-plan.md
@/Users/connecteddale/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-feedback-error-handling/03-RESEARCH.md

Key patterns from research:
- UNUserNotificationCenter for modern macOS notifications
- Request notification permission with .alert and .sound options
- UNMutableNotificationContent for notification content
- UNNotificationRequest with nil trigger for immediate delivery
- Notifications work even if permission denied (just won't display), so not critical path
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create NotificationManager for system notifications</name>
  <files>OptionC/Services/NotificationManager.swift</files>
  <action>
Create NotificationManager class at OptionC/Services/NotificationManager.swift with @MainActor isolation.

Use singleton pattern: `static let shared = NotificationManager()`
Private init to enforce singleton.

Implement methods:

1. requestPermission() async -> Bool
   - Use UNUserNotificationCenter.current().requestAuthorization(options: [.alert, .sound])
   - Wrap in do/catch, return false on error
   - Return true if authorized

2. showSuccess(transcription: String)
   - Create UNMutableNotificationContent with:
     - title: "Transcription Ready"
     - subtitle: "Copied to clipboard"
     - body: First 100 characters of transcription + "..." if longer
     - sound: .default
   - Create UNNotificationRequest with UUID identifier and nil trigger (immediate)
   - Add to UNUserNotificationCenter.current()

3. showError(_ error: AppError)
   - Create UNMutableNotificationContent with:
     - title: error.errorDescription ?? "Error"
     - body: error.recoverySuggestion ?? "Please try again"
     - sound: .defaultCritical (draws more attention)
   - Create and deliver notification immediately

4. showTimeout()
   - Create UNMutableNotificationContent with:
     - title: "No Speech Detected"
     - body: "Recording timed out after 30 seconds. Please try again."
     - sound: .default
   - Create and deliver notification immediately

Import UserNotifications framework.
Note: This file does NOT import AppError directly yet - that wiring happens in Plan 03.
  </action>
  <verify>
- File exists at OptionC/Services/NotificationManager.swift
- Build succeeds: `xcodebuild -project OptionC.xcodeproj -scheme OptionC -destination 'platform=macOS' build 2>&1 | grep -E "(error:|warning:|BUILD SUCCEEDED|BUILD FAILED)"`
- NotificationManager has all four methods
- Uses UNUserNotificationCenter
  </verify>
  <done>
NotificationManager exists as singleton with requestPermission, showSuccess, showError, and showTimeout methods. Uses UNUserNotificationCenter for modern notification delivery. No build errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Request notification permission at app launch</name>
  <files>OptionC/OptionCApp.swift</files>
  <action>
Modify OptionCApp.swift to request notification permission when app launches.

Add an init() method to the App struct (or use existing @StateObject initialization) that triggers permission request:

Option A (if using init):
```swift
init() {
    Task {
        await NotificationManager.shared.requestPermission()
    }
}
```

Option B (if OptionCApp already has complex initialization):
Add .task modifier to MenuBarExtra that runs once on appear:
```swift
MenuBarExtra { ... }
.task {
    await NotificationManager.shared.requestPermission()
}
```

Choose the approach that fits the existing code structure. The key requirement is that notification permission is requested early so notifications work when needed.

Do NOT block app launch on permission result - fire and forget.
  </action>
  <verify>
- OptionCApp.swift includes notification permission request
- Build succeeds: `xcodebuild -project OptionC.xcodeproj -scheme OptionC -destination 'platform=macOS' build 2>&1 | grep -E "(error:|warning:|BUILD SUCCEEDED|BUILD FAILED)"`
- App launches normally (permission request doesn't block)
  </verify>
  <done>
OptionCApp requests notification permission on launch. Permission request is async and non-blocking. App continues to function regardless of permission result.
  </done>
</task>

</tasks>

<verification>
1. NotificationManager.swift exists with all four methods
2. Uses UNUserNotificationCenter modern API (not deprecated NSUserNotification)
3. Success notification shows truncated transcription preview
4. Error notification uses critical sound to draw attention
5. App requests notification permission at launch
6. Clean build with no errors
</verification>

<success_criteria>
- NotificationManager singleton with requestPermission, showSuccess, showError, showTimeout methods
- App requests notification permission at launch (async, non-blocking)
- Notifications use UNUserNotificationCenter (macOS 10.14+ modern API)
- Ready for integration with StateCoordinator (Plan 03)
</success_criteria>

<output>
After completion, create `.planning/phases/03-feedback-error-handling/03-02-SUMMARY.md`
</output>
