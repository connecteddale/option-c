---
phase: 03-feedback-error-handling
plan: 03
type: execute
wave: 2
depends_on: ["03-01", "03-02"]
files_modified:
  - OptionC/State/StateCoordinator.swift
  - OptionC/Services/RecordingController.swift
autonomous: true

must_haves:
  truths:
    - "App returns to idle state after transcription completes or fails"
    - "Timeout notification appears if no speech detected for 30 seconds"
    - "Permission errors trigger notification with recovery guidance"
    - "State machine cannot get stuck in non-idle state"
  artifacts:
    - path: "OptionC/State/StateCoordinator.swift"
      provides: "State transitions with auto-reset and error handling"
      contains: "transitionToSuccess"
      contains: "transitionToError"
    - path: "OptionC/Services/RecordingController.swift"
      provides: "Recording with timeout implementation"
      contains: "withThrowingTaskGroup"
  key_links:
    - from: "OptionC/State/StateCoordinator.swift"
      to: "OptionC/Services/NotificationManager.swift"
      via: "notification on state change"
      pattern: "NotificationManager\\.shared\\.show"
    - from: "OptionC/State/StateCoordinator.swift"
      to: "OptionC/Services/PermissionManager.swift"
      via: "permission check before recording"
      pattern: "permissionManager\\.request"
    - from: "OptionC/Services/RecordingController.swift"
      to: "withThrowingTaskGroup"
      via: "timeout implementation"
      pattern: "withThrowingTaskGroup"
---

<objective>
Integrate error handling, notifications, and state management to create a robust feedback loop that always returns to idle state.

Purpose: The state machine must be bulletproof - users should never get stuck in a non-idle state, and every operation outcome (success, failure, timeout) should produce clear feedback and return to idle.

Output: Updated StateCoordinator with auto-reset transitions and integrated notifications, plus timeout implementation in RecordingController.
</objective>

<execution_context>
@/Users/connecteddale/.claude/get-shit-done/workflows/execute-plan.md
@/Users/connecteddale/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-feedback-error-handling/03-RESEARCH.md
@.planning/phases/03-feedback-error-handling/03-01-SUMMARY.md
@.planning/phases/03-feedback-error-handling/03-02-SUMMARY.md

Key patterns from research:
- Auto-reset to idle after 2-3 seconds for success/error states
- withThrowingTaskGroup for timeout implementation (race operation vs sleep)
- Permission checks before EVERY recording operation, not just at launch
- State transitions always end in idle (no stuck states)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add timeout implementation to RecordingController</name>
  <files>OptionC/Services/RecordingController.swift</files>
  <action>
Add timeout wrapper to RecordingController for transcription operations.

Create a generic timeout helper function:
```swift
func withTimeout<T>(
    seconds: TimeInterval,
    operation: @escaping @Sendable () async throws -> T
) async throws -> T {
    try await withThrowingTaskGroup(of: T.self) { group in
        // Add timeout task
        group.addTask {
            try await Task.sleep(for: .seconds(seconds))
            throw AppError.transcriptionTimeout
        }

        // Add actual operation
        group.addTask {
            try await operation()
        }

        // Wait for first to complete
        let result = try await group.next()!

        // Cancel remaining tasks
        group.cancelAll()

        return result
    }
}
```

Wrap the transcription operation in this timeout with 30 second limit.

Update stopRecording() or processTranscription() to use the timeout wrapper:
- Catch AppError.transcriptionTimeout specifically
- Re-throw or convert to appropriate error for StateCoordinator to handle

Import the AppError type from Models/AppError.swift.
  </action>
  <verify>
- RecordingController includes timeout implementation
- Build succeeds: `xcodebuild -project OptionC.xcodeproj -scheme OptionC -destination 'platform=macOS' build 2>&1 | grep -E "(error:|warning:|BUILD SUCCEEDED|BUILD FAILED)"`
- Timeout throws AppError.transcriptionTimeout after 30 seconds
  </verify>
  <done>
RecordingController has withTimeout helper function. Transcription operations are wrapped with 30-second timeout. AppError.transcriptionTimeout is thrown on timeout. Clean build.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update StateCoordinator with integrated error handling and auto-reset</name>
  <files>OptionC/State/StateCoordinator.swift</files>
  <action>
Update StateCoordinator to integrate PermissionManager, NotificationManager, and auto-reset behavior.

1. Add dependency references:
```swift
private let permissionManager = PermissionManager()
```

2. Add state transition methods with auto-reset:
```swift
func transitionToSuccess(transcription: String) {
    currentState = .success(transcription: transcription)
    NotificationManager.shared.showSuccess(transcription: transcription)

    Task {
        try? await Task.sleep(for: .seconds(2))
        currentState = .idle
    }
}

func transitionToError(_ error: AppError) {
    currentState = .error(error)
    NotificationManager.shared.showError(error)

    Task {
        try? await Task.sleep(for: .seconds(3))
        currentState = .idle
    }
}
```

3. Update startRecording() to check permissions first:
```swift
func startRecording() async {
    // Check microphone permission
    let micResult = await permissionManager.requestMicrophonePermission()
    guard case .success = micResult else {
        if case .failure(let error) = micResult {
            transitionToError(error)
        }
        return
    }

    // Check speech recognition permission
    let speechResult = await permissionManager.requestSpeechRecognitionPermission()
    guard case .success = speechResult else {
        if case .failure(let error) = speechResult {
            transitionToError(error)
        }
        return
    }

    // Permissions granted, proceed with recording
    do {
        try recordingController.startRecording()
        currentState = .recording(startTime: Date())
    } catch {
        transitionToError(.recordingFailed(underlying: error))
    }
}
```

4. Update processTranscription to handle all error cases:
```swift
func processTranscription() async {
    currentState = .processing(startTime: Date())

    do {
        let transcription = try await withTimeout(seconds: 30) {
            await self.recordingController.getTranscription()
        }

        guard !transcription.isEmpty else {
            transitionToError(.noSpeechDetected)
            return
        }

        // Copy to clipboard
        try ClipboardManager.copy(transcription)
        transitionToSuccess(transcription: transcription)

    } catch AppError.transcriptionTimeout {
        NotificationManager.shared.showTimeout()
        currentState = .idle  // Direct to idle for timeout

    } catch let error as AppError {
        transitionToError(error)

    } catch {
        transitionToError(.recordingFailed(underlying: error))
    }
}
```

5. Ensure AppState enum includes success and error cases if not already:
```swift
enum AppState {
    case idle
    case recording(startTime: Date)
    case processing(startTime: Date)
    case success(transcription: String)
    case error(AppError)
}
```

Import AppError and ensure all error paths lead back to idle state.
  </action>
  <verify>
- StateCoordinator has transitionToSuccess and transitionToError methods
- Both transition methods auto-reset to idle after delay
- Permission checks happen before recording starts
- All error cases handled with notification and reset to idle
- Build succeeds: `xcodebuild -project OptionC.xcodeproj -scheme OptionC -destination 'platform=macOS' build 2>&1 | grep -E "(error:|warning:|BUILD SUCCEEDED|BUILD FAILED)"`
  </verify>
  <done>
StateCoordinator integrates PermissionManager and NotificationManager. All state transitions auto-reset to idle. Permission errors show notification with recovery guidance. Timeout shows specific timeout notification. No code path leaves state stuck in non-idle. Clean build.
  </done>
</task>

</tasks>

<verification>
1. Permission denied triggers notification with recovery suggestion
2. Success triggers notification with transcription preview and resets to idle after 2s
3. Error triggers notification with error details and resets to idle after 3s
4. Timeout triggers specific timeout notification and resets to idle
5. Rapid Option-C presses after completion work correctly (state is idle)
6. Clean build with no errors
</verification>

<success_criteria>
- StateCoordinator never gets stuck in non-idle state
- All 6 success criteria from Phase 3 are met:
  1. Notification appears when transcription is ready and copied to clipboard
  2. Notification appears if transcription fails (with reason)
  3. App returns to idle state after transcription completes or fails
  4. User sees clear message if microphone permission is missing
  5. User sees clear message if speech recognition permission is missing
  6. Timeout notification appears if no speech detected for 30 seconds
- Integration between PermissionManager, NotificationManager, and StateCoordinator is complete
</success_criteria>

<output>
After completion, create `.planning/phases/03-feedback-error-handling/03-03-SUMMARY.md`
</output>
